Starting program: /home/dlamartina/School/CS362/CS362-W2019/projects/lamartid/nelsoryaDominion/randomtestadventurer 

Program received signal SIGABRT, Aborted.
__GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50
50	../sysdeps/unix/sysv/linux/raise.c: No such file or directory.
Breakpoint 1 at 0x55555555c13f: file dominion.c, line 648.
Starting program: /home/dlamartina/School/CS362/CS362-W2019/projects/lamartid/nelsoryaDominion/randomtestadventurer 

Breakpoint 1, adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=0, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:648
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=1, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=0, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=1, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=1, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=1, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=2, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=1, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=3, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=1, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=4, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=1, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=5, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=1, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=6, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=1, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=7, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=1, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=8, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=1, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=9, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=1, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=10, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
650		  shuffle(currentPlayer, state);
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=11, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:652
652		drawCard(currentPlayer, state);
drawCard (player=1, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
533	    for (i = 0; i < state->discardCount[player];i++){
538	    state->deckCount[player] = state->discardCount[player];
539	    state->discardCount[player] = 0;//Reset discard
542	    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
drawCard (player=1, state=0x7fffffff7620) at dominion.c:548
548	    state->discardCount[player] = 0;
551	    count = state->handCount[player];//Get current player's hand count
557	    deckCounter = state->deckCount[player];//Create a holder for the deck count
559	    if (deckCounter == 0)
560	      return -1;
581	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=11, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
650		  shuffle(currentPlayer, state);
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=12, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:652
652		drawCard(currentPlayer, state);
drawCard (player=1, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
533	    for (i = 0; i < state->discardCount[player];i++){
538	    state->deckCount[player] = state->discardCount[player];
539	    state->discardCount[player] = 0;//Reset discard
542	    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
drawCard (player=1, state=0x7fffffff7620) at dominion.c:548
548	    state->discardCount[player] = 0;
551	    count = state->handCount[player];//Get current player's hand count
557	    deckCounter = state->deckCount[player];//Create a holder for the deck count
559	    if (deckCounter == 0)
560	      return -1;
581	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=12, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
650		  shuffle(currentPlayer, state);
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=23, z=13, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:652
652		drawCard(currentPlayer, state);
drawCard (player=1, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
533	    for (i = 0; i < state->discardCount[player];i++){
538	    state->deckCount[player] = state->discardCount[player];
539	    state->discardCount[player] = 0;//Reset discard
542	    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
drawCard (player=1, state=0x7fffffff7620) at dominion.c:548
548	    state->discardCount[player] = 0;
551	    count = state->handCount[player];//Get current player's hand count
557	    deckCounter = state->deckCount[player];//Create a holder for the deck count
559	    if (deckCounter == 0)
560	      return -1;
581	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=23, z=13, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
655		  drawntreasure++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
650		  shuffle(currentPlayer, state);
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
adventureEffect (drawntreasure=1, currentPlayer=1, cardDrawn=4, z=13, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:652
652		drawCard(currentPlayer, state);
drawCard (player=1, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
533	    for (i = 0; i < state->discardCount[player];i++){
538	    state->deckCount[player] = state->discardCount[player];
539	    state->discardCount[player] = 0;//Reset discard
542	    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
drawCard (player=1, state=0x7fffffff7620) at dominion.c:548
548	    state->discardCount[player] = 0;
551	    count = state->handCount[player];//Get current player's hand count
557	    deckCounter = state->deckCount[player];//Create a holder for the deck count
559	    if (deckCounter == 0)
560	      return -1;
581	}
adventureEffect (drawntreasure=1, currentPlayer=1, cardDrawn=4, z=13, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
655		  drawntreasure++;
648	   while(drawntreasure<2){
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
667	   return 0;
668	}
cardEffect (card=7, choice1=0, choice2=0, choice3=0, state=0x7fffffff7620, handPos=1, bonus=0x7ffffffd6590) at dominion.c:1249
1249	}
main (argc=1, argv=0x7fffffffddd8) at randomtestadventurer.c:137
137	    assertEqualValPair(testG.handCount[currentPlayer], G.handCount[currentPlayer] + draw_total - discarded, hand_count_current, &hand_count_current_errors, dep);
assertEqualValPair (actual=5, expected=8, err_arr=0x7ffffffd6660, counter=0x7ffffffd654c, dep=...) at test_helpers.c:31
31	  if (!(actual == expected)){
32	    err_arr[*counter].actual = actual;
33	    err_arr[*counter].expected = expected;
34	    err_arr[*counter].dep = dep;
35	    (*counter)++;
37	}
main (argc=1, argv=0x7fffffffddd8) at randomtestadventurer.c:138
138	    assertEqualValPair(testG.deckCount[currentPlayer], G.deckCount[currentPlayer] - draw_total, deck_count_current, &deck_count_current_errors, dep);
assertEqualValPair (actual=0, expected=3, err_arr=0x7ffffffd7f60, counter=0x7ffffffd6550, dep=...) at test_helpers.c:31
31	  if (!(actual == expected)){
32	    err_arr[*counter].actual = actual;
33	    err_arr[*counter].expected = expected;
34	    err_arr[*counter].dep = dep;
35	    (*counter)++;
37	}
main (argc=1, argv=0x7fffffffddd8) at randomtestadventurer.c:139
139	    assertEqualValPair(testG.discardCount[currentPlayer], G.discardCount[currentPlayer] + discarded, discard_count_current, &discard_count_current_errors, dep);
assertEqualValPair (actual=13, expected=7, err_arr=0x7ffffffd9860, counter=0x7ffffffd6554, dep=...) at test_helpers.c:31
31	  if (!(actual == expected)){
32	    err_arr[*counter].actual = actual;
33	    err_arr[*counter].expected = expected;
34	    err_arr[*counter].dep = dep;
35	    (*counter)++;
37	}
main (argc=1, argv=0x7fffffffddd8) at randomtestadventurer.c:140
140	    num_treasure_actual = countTreasure(testG.hand[currentPlayer], testG.handCount[currentPlayer]);
countTreasure (cards=0x7fffffff7ee8, size=5) at test_helpers.c:226
226	    int treasure_count = 0;
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
232	    return treasure_count;
233	}
main (argc=1, argv=0x7fffffffddd8) at randomtestadventurer.c:141
141	    num_treasure_expected = countTreasure(G.hand[currentPlayer], G.handCount[currentPlayer]) + drawnTreasure;
countTreasure (cards=0x7fffffff1828, size=7) at test_helpers.c:226
226	    int treasure_count = 0;
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
229	            treasure_count++;
227	    for (int i = 0; i < size; i++){
232	    return treasure_count;
233	}
main (argc=1, argv=0x7fffffffddd8) at randomtestadventurer.c:142
142	    assertEqualValPair(num_treasure_actual, num_treasure_expected, treasure_in_hand_current, &treasure_in_hand_current_errors, dep);
assertEqualValPair (actual=0, expected=1, err_arr=0x7ffffffdb160, counter=0x7ffffffd6558, dep=...) at test_helpers.c:31
31	  if (!(actual == expected)){
32	    err_arr[*counter].actual = actual;
33	    err_arr[*counter].expected = expected;
34	    err_arr[*counter].dep = dep;
35	    (*counter)++;
37	}
main (argc=1, argv=0x7fffffffddd8) at randomtestadventurer.c:143
143	    num_treasure_actual = countTreasure(testG.deck[currentPlayer], testG.deckCount[currentPlayer]);
countTreasure (cards=0x7fffffff9e38, size=0) at test_helpers.c:226
226	    int treasure_count = 0;
227	    for (int i = 0; i < size; i++){
232	    return treasure_count;
233	}
main (argc=1, argv=0x7fffffffddd8) at randomtestadventurer.c:144
144	    num_treasure_expected = countTreasure(G.deck[currentPlayer], G.deckCount[currentPlayer]) - drawnTreasure;
countTreasure (cards=0x7fffffff3778, size=11) at test_helpers.c:226
226	    int treasure_count = 0;
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
229	            treasure_count++;
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
229	            treasure_count++;
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
232	    return treasure_count;
233	}
main (argc=1, argv=0x7fffffffddd8) at randomtestadventurer.c:145
145	    assertEqualValPair(num_treasure_actual, num_treasure_expected, treasure_in_deck_current, &treasure_in_deck_current_errors, dep);
assertEqualValPair (actual=0, expected=2, err_arr=0x7ffffffdca60, counter=0x7ffffffd655c, dep=...) at test_helpers.c:31
31	  if (!(actual == expected)){
32	    err_arr[*counter].actual = actual;
33	    err_arr[*counter].expected = expected;
34	    err_arr[*counter].dep = dep;
35	    (*counter)++;
37	}
main (argc=1, argv=0x7fffffffddd8) at randomtestadventurer.c:148
148	    assertEqualValPair(testG.handCount[otherPlayer], G.handCount[otherPlayer], hand_count_other, &hand_count_other_errors, dep);
assertEqualValPair (actual=5, expected=5, err_arr=0x7ffffffde360, counter=0x7ffffffd6560, dep=...) at test_helpers.c:31
31	  if (!(actual == expected)){
37	}
main (argc=1, argv=0x7fffffffddd8) at randomtestadventurer.c:149
149	    assertEqualValPair(testG.deckCount[otherPlayer], G.deckCount[otherPlayer], deck_count_other, &deck_count_other_errors, dep);
assertEqualValPair (actual=5, expected=5, err_arr=0x7ffffffdfc60, counter=0x7ffffffd6564, dep=...) at test_helpers.c:31
31	  if (!(actual == expected)){
37	}
main (argc=1, argv=0x7fffffffddd8) at randomtestadventurer.c:150
150	    assertEqualValPair(testG.discardCount[otherPlayer], G.discardCount[otherPlayer], discard_count_other, &discard_count_other_errors, dep);
assertEqualValPair (actual=0, expected=0, err_arr=0x7ffffffe1560, counter=0x7ffffffd6568, dep=...) at test_helpers.c:31
31	  if (!(actual == expected)){
37	}
main (argc=1, argv=0x7fffffffddd8) at randomtestadventurer.c:151
151	    num_treasure_actual = countTreasure(testG.hand[otherPlayer], testG.handCount[otherPlayer]);
countTreasure (cards=0x7fffffff7718, size=5) at test_helpers.c:226
226	    int treasure_count = 0;
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
229	            treasure_count++;
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
229	            treasure_count++;
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
229	            treasure_count++;
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
229	            treasure_count++;
227	    for (int i = 0; i < size; i++){
232	    return treasure_count;
233	}
main (argc=1, argv=0x7fffffffddd8) at randomtestadventurer.c:152
152	    num_treasure_expected = countTreasure(G.hand[otherPlayer], G.handCount[otherPlayer]);
countTreasure (cards=0x7fffffff1058, size=5) at test_helpers.c:226
226	    int treasure_count = 0;
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
229	            treasure_count++;
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
229	            treasure_count++;
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
229	            treasure_count++;
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
229	            treasure_count++;
227	    for (int i = 0; i < size; i++){
232	    return treasure_count;
233	}
main (argc=1, argv=0x7fffffffddd8) at randomtestadventurer.c:153
153	    assertEqualValPair(num_treasure_actual, num_treasure_expected, treasure_in_hand_other, &treasure_in_hand_other_errors, dep);
assertEqualValPair (actual=4, expected=4, err_arr=0x7ffffffe2e60, counter=0x7ffffffd656c, dep=...) at test_helpers.c:31
31	  if (!(actual == expected)){
37	}
main (argc=1, argv=0x7fffffffddd8) at randomtestadventurer.c:154
154	    num_treasure_actual = countTreasure(testG.deck[otherPlayer], testG.deckCount[otherPlayer]);
countTreasure (cards=0x7fffffff9668, size=5) at test_helpers.c:226
226	    int treasure_count = 0;
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
229	            treasure_count++;
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
229	            treasure_count++;
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
229	            treasure_count++;
227	    for (int i = 0; i < size; i++){
232	    return treasure_count;
233	}
main (argc=1, argv=0x7fffffffddd8) at randomtestadventurer.c:155
155	    num_treasure_expected = countTreasure(G.deck[otherPlayer], G.deckCount[otherPlayer]);
countTreasure (cards=0x7fffffff2fa8, size=5) at test_helpers.c:226
226	    int treasure_count = 0;
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
229	            treasure_count++;
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
229	            treasure_count++;
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
229	            treasure_count++;
227	    for (int i = 0; i < size; i++){
232	    return treasure_count;
233	}
main (argc=1, argv=0x7fffffffddd8) at randomtestadventurer.c:156
156	    assertEqualValPair(num_treasure_actual, num_treasure_expected, treasure_in_deck_other, &treasure_in_deck_other_errors, dep);
assertEqualValPair (actual=3, expected=3, err_arr=0x7ffffffe4760, counter=0x7ffffffd6570, dep=...) at test_helpers.c:31
31	  if (!(actual == expected)){
37	}
main (argc=1, argv=0x7fffffffddd8) at randomtestadventurer.c:159
159	    assertEqualValPair(testG.numBuys, G.numBuys + extraBuys, num_buys_diff, &num_buys_diff_errors, dep);
assertEqualValPair (actual=1, expected=1, err_arr=0x7ffffffe6060, counter=0x7ffffffd6574, dep=...) at test_helpers.c:31
31	  if (!(actual == expected)){
37	}
main (argc=1, argv=0x7fffffffddd8) at randomtestadventurer.c:160
160	    bool same_supply = true;
161	    for (int i = 0; i < cards_count; i++){
162	       if (testG.supplyCount[i] != G.supplyCount[i]){
161	    for (int i = 0; i < cards_count; i++){
162	       if (testG.supplyCount[i] != G.supplyCount[i]){
161	    for (int i = 0; i < cards_count; i++){
162	       if (testG.supplyCount[i] != G.supplyCount[i]){
161	    for (int i = 0; i < cards_count; i++){
162	       if (testG.supplyCount[i] != G.supplyCount[i]){
161	    for (int i = 0; i < cards_count; i++){
162	       if (testG.supplyCount[i] != G.supplyCount[i]){
161	    for (int i = 0; i < cards_count; i++){
162	       if (testG.supplyCount[i] != G.supplyCount[i]){
161	    for (int i = 0; i < cards_count; i++){
162	       if (testG.supplyCount[i] != G.supplyCount[i]){
161	    for (int i = 0; i < cards_count; i++){
162	       if (testG.supplyCount[i] != G.supplyCount[i]){
161	    for (int i = 0; i < cards_count; i++){
162	       if (testG.supplyCount[i] != G.supplyCount[i]){
161	    for (int i = 0; i < cards_count; i++){
162	       if (testG.supplyCount[i] != G.supplyCount[i]){
161	    for (int i = 0; i < cards_count; i++){
162	       if (testG.supplyCount[i] != G.supplyCount[i]){
161	    for (int i = 0; i < cards_count; i++){
162	       if (testG.supplyCount[i] != G.supplyCount[i]){
161	    for (int i = 0; i < cards_count; i++){
162	       if (testG.supplyCount[i] != G.supplyCount[i]){
161	    for (int i = 0; i < cards_count; i++){
162	       if (testG.supplyCount[i] != G.supplyCount[i]){
161	    for (int i = 0; i < cards_count; i++){
162	       if (testG.supplyCount[i] != G.supplyCount[i]){
161	    for (int i = 0; i < cards_count; i++){
162	       if (testG.supplyCount[i] != G.supplyCount[i]){
161	    for (int i = 0; i < cards_count; i++){
162	       if (testG.supplyCount[i] != G.supplyCount[i]){
161	    for (int i = 0; i < cards_count; i++){
162	       if (testG.supplyCount[i] != G.supplyCount[i]){
161	    for (int i = 0; i < cards_count; i++){
162	       if (testG.supplyCount[i] != G.supplyCount[i]){
161	    for (int i = 0; i < cards_count; i++){
162	       if (testG.supplyCount[i] != G.supplyCount[i]){
161	    for (int i = 0; i < cards_count; i++){
162	       if (testG.supplyCount[i] != G.supplyCount[i]){
161	    for (int i = 0; i < cards_count; i++){
162	       if (testG.supplyCount[i] != G.supplyCount[i]){
161	    for (int i = 0; i < cards_count; i++){
162	       if (testG.supplyCount[i] != G.supplyCount[i]){
161	    for (int i = 0; i < cards_count; i++){
162	       if (testG.supplyCount[i] != G.supplyCount[i]){
161	    for (int i = 0; i < cards_count; i++){
162	       if (testG.supplyCount[i] != G.supplyCount[i]){
161	    for (int i = 0; i < cards_count; i++){
162	       if (testG.supplyCount[i] != G.supplyCount[i]){
161	    for (int i = 0; i < cards_count; i++){
162	       if (testG.supplyCount[i] != G.supplyCount[i]){
161	    for (int i = 0; i < cards_count; i++){
166	    if (!same_supply){
169	    bool same_tokens = true;
170	    for (int i = 0; i < cards_count; i++){
171	       if (testG.embargoTokens[i] != G.embargoTokens[i]){
170	    for (int i = 0; i < cards_count; i++){
171	       if (testG.embargoTokens[i] != G.embargoTokens[i]){
170	    for (int i = 0; i < cards_count; i++){
171	       if (testG.embargoTokens[i] != G.embargoTokens[i]){
170	    for (int i = 0; i < cards_count; i++){
171	       if (testG.embargoTokens[i] != G.embargoTokens[i]){
170	    for (int i = 0; i < cards_count; i++){
171	       if (testG.embargoTokens[i] != G.embargoTokens[i]){
170	    for (int i = 0; i < cards_count; i++){
171	       if (testG.embargoTokens[i] != G.embargoTokens[i]){
170	    for (int i = 0; i < cards_count; i++){
171	       if (testG.embargoTokens[i] != G.embargoTokens[i]){
170	    for (int i = 0; i < cards_count; i++){
171	       if (testG.embargoTokens[i] != G.embargoTokens[i]){
170	    for (int i = 0; i < cards_count; i++){
171	       if (testG.embargoTokens[i] != G.embargoTokens[i]){
170	    for (int i = 0; i < cards_count; i++){
171	       if (testG.embargoTokens[i] != G.embargoTokens[i]){
170	    for (int i = 0; i < cards_count; i++){
171	       if (testG.embargoTokens[i] != G.embargoTokens[i]){
170	    for (int i = 0; i < cards_count; i++){
171	       if (testG.embargoTokens[i] != G.embargoTokens[i]){
170	    for (int i = 0; i < cards_count; i++){
171	       if (testG.embargoTokens[i] != G.embargoTokens[i]){
170	    for (int i = 0; i < cards_count; i++){
171	       if (testG.embargoTokens[i] != G.embargoTokens[i]){
170	    for (int i = 0; i < cards_count; i++){
171	       if (testG.embargoTokens[i] != G.embargoTokens[i]){
170	    for (int i = 0; i < cards_count; i++){
171	       if (testG.embargoTokens[i] != G.embargoTokens[i]){
170	    for (int i = 0; i < cards_count; i++){
171	       if (testG.embargoTokens[i] != G.embargoTokens[i]){
170	    for (int i = 0; i < cards_count; i++){
171	       if (testG.embargoTokens[i] != G.embargoTokens[i]){
170	    for (int i = 0; i < cards_count; i++){
171	       if (testG.embargoTokens[i] != G.embargoTokens[i]){
170	    for (int i = 0; i < cards_count; i++){
171	       if (testG.embargoTokens[i] != G.embargoTokens[i]){
170	    for (int i = 0; i < cards_count; i++){
171	       if (testG.embargoTokens[i] != G.embargoTokens[i]){
170	    for (int i = 0; i < cards_count; i++){
171	       if (testG.embargoTokens[i] != G.embargoTokens[i]){
170	    for (int i = 0; i < cards_count; i++){
171	       if (testG.embargoTokens[i] != G.embargoTokens[i]){
170	    for (int i = 0; i < cards_count; i++){
171	       if (testG.embargoTokens[i] != G.embargoTokens[i]){
170	    for (int i = 0; i < cards_count; i++){
171	       if (testG.embargoTokens[i] != G.embargoTokens[i]){
170	    for (int i = 0; i < cards_count; i++){
171	       if (testG.embargoTokens[i] != G.embargoTokens[i]){
170	    for (int i = 0; i < cards_count; i++){
171	       if (testG.embargoTokens[i] != G.embargoTokens[i]){
170	    for (int i = 0; i < cards_count; i++){
175	    if (!same_tokens){
178	    assertEqualValPair(testG.outpostPlayed, G.outpostPlayed, outpost_play_diff, &outpost_play_errors, dep);
assertEqualValPair (actual=0, expected=0, err_arr=0x7ffffffe7960, counter=0x7ffffffd6578, dep=...) at test_helpers.c:31
31	  if (!(actual == expected)){
37	}
main (argc=1, argv=0x7fffffffddd8) at randomtestadventurer.c:179
179	    assertEqualValPair(testG.outpostTurn, G.outpostTurn, outpost_turn_diff, &outpost_turn_errors, dep);
assertEqualValPair (actual=0, expected=0, err_arr=0x7ffffffe9260, counter=0x7ffffffd657c, dep=...) at test_helpers.c:31
31	  if (!(actual == expected)){
37	}
main (argc=1, argv=0x7fffffffddd8) at randomtestadventurer.c:180
180	    assertEqualValPair(testG.whoseTurn, G.whoseTurn, whose_turn_diff, &whose_turn_errors, dep);
assertEqualValPair (actual=1, expected=1, err_arr=0x7ffffffeab60, counter=0x7ffffffd6580, dep=...) at test_helpers.c:31
31	  if (!(actual == expected)){
37	}
main (argc=1, argv=0x7fffffffddd8) at randomtestadventurer.c:181
181	    assertEqualValPair(testG.phase, G.phase, phase_diff, &phase_errors, dep);
assertEqualValPair (actual=0, expected=0, err_arr=0x7ffffffec460, counter=0x7ffffffd6584, dep=...) at test_helpers.c:31
31	  if (!(actual == expected)){
37	}
main (argc=1, argv=0x7fffffffddd8) at randomtestadventurer.c:182
182	    assertEqualValPair(testG.numActions, G.numActions + extraActions, num_action_diff, &num_action_errors, dep);
assertEqualValPair (actual=1, expected=1, err_arr=0x7ffffffedd60, counter=0x7ffffffd6588, dep=...) at test_helpers.c:31
31	  if (!(actual == expected)){
37	}
main (argc=1, argv=0x7fffffffddd8) at randomtestadventurer.c:183
183	    assertEqualValPair(testG.playedCardCount, G.playedCardCount + cardsPlayed, played_card_diff, &played_card_errors, dep);
assertEqualValPair (actual=0, expected=1, err_arr=0x7ffffffef660, counter=0x7ffffffd658c, dep=...) at test_helpers.c:31
31	  if (!(actual == expected)){
32	    err_arr[*counter].actual = actual;
33	    err_arr[*counter].expected = expected;
34	    err_arr[*counter].dep = dep;
35	    (*counter)++;
37	}
main (argc=1, argv=0x7fffffffddd8) at randomtestadventurer.c:69
69	  for (int i = 0; i < NUM_TESTS; i++){
75	    int choice1 = 0, choice2 = 0, choice3 = 0, bonus = 0;
76	    int drawnTreasure = 0;
77	    int treasure_needed = 2;  // What adventurer requires of deck
78	    int extraBuys = 0;
79	    int extraActions = 0;
80	    int cardsPlayed = 1;
86	    int discarded = 1;      // At least the 1 Adventurer card will be discarded
92	    initializeGame(numPlayers, k, seed, &G);
initializeGame (numPlayers=2, kingdomCards=0x7ffffffd65f0, randomSeed=1000, state=0x7fffffff0f60) at dominion.c:44
44	  SelectStream(1);
SelectStream (index=1) at rngs.c:147
147	  stream = ((unsigned int) index) % STREAMS;
148	  if ((initialized == 0) && (stream != 0))   /* protect against        */
150	}
initializeGame (numPlayers=2, kingdomCards=0x7ffffffd65f0, randomSeed=1000, state=0x7fffffff0f60) at dominion.c:45
45	  PutSeed((long)randomSeed);
PutSeed (x=1000) at rngs.c:111
111	  char ok = 0;
113	  if (x > 0)
114	    x = x % MODULUS;                       /* correct if x is too large  */
115	  if (x < 0)                                 
117	  if (x == 0)                                
125	  seed[stream] = x;
126	}
initializeGame (numPlayers=2, kingdomCards=0x7ffffffd65f0, randomSeed=1000, state=0x7fffffff0f60) at dominion.c:48
48	  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
54	  state->numPlayers = numPlayers;
57	  for (i = 0; i < 10; i++)
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
57	  for (i = 0; i < 10; i++)
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
57	  for (i = 0; i < 10; i++)
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
57	  for (i = 0; i < 10; i++)
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
57	  for (i = 0; i < 10; i++)
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
57	  for (i = 0; i < 10; i++)
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
57	  for (i = 0; i < 10; i++)
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
57	  for (i = 0; i < 10; i++)
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
57	  for (i = 0; i < 10; i++)
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
57	  for (i = 0; i < 10; i++)
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
57	  for (i = 0; i < 10; i++)
73	  if (numPlayers == 2)
75	      state->supplyCount[curse] = 10;
87	  if (numPlayers == 2)
89	      state->supplyCount[estate] = 8;
90	      state->supplyCount[duchy] = 8;
91	      state->supplyCount[province] = 8;
101	  state->supplyCount[copper] = 60 - (7 * numPlayers);
102	  state->supplyCount[silver] = 40;
103	  state->supplyCount[gold] = 30;
106	  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
108	      for (j = 0; j < 10; j++)           		//loop chosen cards
110		  if (kingdomCards[j] == i)
113		      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
122			  state->supplyCount[i] = 10;
124		      break;
106	  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
108	      for (j = 0; j < 10; j++)           		//loop chosen cards
110		  if (kingdomCards[j] == i)
128		      state->supplyCount[i] = -1;
108	      for (j = 0; j < 10; j++)           		//loop chosen cards
110		  if (kingdomCards[j] == i)
128		      state->supplyCount[i] = -1;
108	      for (j = 0; j < 10; j++)           		//loop chosen cards
110		  if (kingdomCards[j] == i)
128		      state->supplyCount[i] = -1;
108	      for (j = 0; j < 10; j++)           		//loop chosen cards
110		  if (kingdomCards[j] == i)
128		      state->supplyCount[i] = -1;
108	      for (j = 0; j < 10; j++)           		//loop chosen cards
110		  if (kingdomCards[j] == i)
128		      state->supplyCount[i] = -1;
108	      for (j = 0; j < 10; j++)           		//loop chosen cards
110		  if (kingdomCards[j] == i)
128		      state->supplyCount[i] = -1;
108	      for (j = 0; j < 10; j++)           		//loop chosen cards
110		  if (kingdomCards[j] == i)
128		      state->supplyCount[i] = -1;
108	      for (j = 0; j < 10; j++)           		//loop chosen cards
110		  if (kingdomCards[j] == i)
128		      state->supplyCount[i] = -1;
108	      for (j = 0; j < 10; j++)           		//loop chosen cards
110		  if (kingdomCards[j] == i)
Starting program: /home/dlamartina/School/CS362/CS362-W2019/projects/lamartid/nelsoryaDominion/randomtestadventurer 

Program received signal SIGABRT, Aborted.
__GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50
50	../sysdeps/unix/sysv/linux/raise.c: No such file or directory.
#0  __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50
#1  0x00007ffff7c61535 in __GI_abort () at abort.c:79
#2  0x00007ffff7cc8516 in __libc_message (action=action@entry=do_abort, fmt=fmt@entry=0x7ffff7dec9ee "*** %s ***: %s terminated\n") at ../sysdeps/posix/libc_fatal.c:181
#3  0x00007ffff7d6c431 in __GI___fortify_fail_abort (need_backtrace=need_backtrace@entry=false, msg=msg@entry=0x7ffff7dec9cc "stack smashing detected") at fortify_fail.c:33
#4  0x00007ffff7d6c3f2 in __stack_chk_fail () at stack_chk_fail.c:29
#5  0x000055555555edda in cardEffect (card=7, choice1=0, choice2=0, choice3=0, state=0x7fffffff7620, handPos=2, bonus=0x7ffffffd6590) at dominion.c:1249
#6  0x0000000000000000 in ?? ()
0x7ffff7dec9cc:	0x63617473
0x7ffff7dec9ee:	0x202a2a2a
Starting program: /home/dlamartina/School/CS362/CS362-W2019/projects/lamartid/nelsoryaDominion/randomtestadventurer 

Program received signal SIGABRT, Aborted.
__GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50
50	../sysdeps/unix/sysv/linux/raise.c: No such file or directory.
#0  __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50
#1  0x00007ffff7c61535 in __GI_abort () at abort.c:79
#2  0x00007ffff7cc8516 in __libc_message (action=action@entry=do_abort, fmt=fmt@entry=0x7ffff7dec9ee "*** %s ***: %s terminated\n") at ../sysdeps/posix/libc_fatal.c:181
#3  0x00007ffff7d6c431 in __GI___fortify_fail_abort (need_backtrace=need_backtrace@entry=false, msg=msg@entry=0x7ffff7dec9cc "stack smashing detected") at fortify_fail.c:33
#4  0x00007ffff7d6c3f2 in __stack_chk_fail () at stack_chk_fail.c:29
#5  0x000055555555edda in cardEffect (card=7, choice1=0, choice2=0, choice3=0, state=0x7fffffff7620, handPos=0, bonus=0x7ffffffd6590) at dominion.c:1249
#6  0x0000000000000000 in ?? ()
0x7fffffff7620:	0x00000002
#0  __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50
#1  0x00007ffff7c61535 in __GI_abort () at abort.c:79
#2  0x00007ffff7cc8516 in __libc_message (action=action@entry=do_abort, fmt=fmt@entry=0x7ffff7dec9ee "*** %s ***: %s terminated\n") at ../sysdeps/posix/libc_fatal.c:181
#3  0x00007ffff7d6c431 in __GI___fortify_fail_abort (need_backtrace=need_backtrace@entry=false, msg=msg@entry=0x7ffff7dec9cc "stack smashing detected") at fortify_fail.c:33
#4  0x00007ffff7d6c3f2 in __stack_chk_fail () at stack_chk_fail.c:29
#5  0x000055555555edda in cardEffect (card=7, choice1=0, choice2=0, choice3=0, state=0x7fffffff7620, handPos=0, bonus=0x7ffffffd6590) at dominion.c:1249
#6  0x0000000000000000 in ?? ()

Program terminated with signal SIGABRT, Aborted.
The program no longer exists.
0x7ffff7dec9cc:	0x63617473
0x7ffff7dec9ee:	0x202a2a2a
Breakpoint 1 at 0x55555555c13f: file dominion.c, line 648.
Starting program: /home/dlamartina/School/CS362/CS362-W2019/projects/lamartid/nelsoryaDominion/randomtestadventurer 

Breakpoint 1, adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=0, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:648
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}
adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=0, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}
adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=1, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}
adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=2, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}
adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=3, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}
adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=4, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}
adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=5, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}
adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=6, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}
adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=7, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}
adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=8, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}
adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=9, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}
adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=10, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}
adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=11, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}
adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=12, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}
adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=13, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}
adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=14, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}
adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=15, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}
adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=16, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}
adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=17, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}
adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=18, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}
adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=19, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}
adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=20, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}
adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=21, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}
adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=22, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}
adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=23, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}
adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=24, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}
adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=25, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}
adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=26, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}
adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=27, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}
adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=28, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}
adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=29, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}
adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=30, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}
adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=31, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}
adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=32, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}
adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=33, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}
adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=34, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}
adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=35, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}
adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=36, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}
adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=37, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}
adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=38, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}
adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=39, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}
adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=40, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}
adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=41, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}
adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=42, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}
adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=43, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
650		  shuffle(currentPlayer, state);
shuffle (player=0, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=44, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:652
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
533	    for (i = 0; i < state->discardCount[player];i++){
538	    state->deckCount[player] = state->discardCount[player];
539	    state->discardCount[player] = 0;//Reset discard
542	    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
shuffle (player=0, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
drawCard (player=0, state=0x7fffffff7620) at dominion.c:548
548	    state->discardCount[player] = 0;
551	    count = state->handCount[player];//Get current player's hand count
557	    deckCounter = state->deckCount[player];//Create a holder for the deck count
559	    if (deckCounter == 0)
560	      return -1;
581	}
adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=44, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
650		  shuffle(currentPlayer, state);
shuffle (player=0, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=45, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:652
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
533	    for (i = 0; i < state->discardCount[player];i++){
538	    state->deckCount[player] = state->discardCount[player];
539	    state->discardCount[player] = 0;//Reset discard
542	    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
shuffle (player=0, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
drawCard (player=0, state=0x7fffffff7620) at dominion.c:548
548	    state->discardCount[player] = 0;
551	    count = state->handCount[player];//Get current player's hand count
557	    deckCounter = state->deckCount[player];//Create a holder for the deck count
559	    if (deckCounter == 0)
560	      return -1;
581	}
adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=45, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
650		  shuffle(currentPlayer, state);
shuffle (player=0, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=14, z=46, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:652
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
533	    for (i = 0; i < state->discardCount[player];i++){
538	    state->deckCount[player] = state->discardCount[player];
539	    state->discardCount[player] = 0;//Reset discard
542	    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
shuffle (player=0, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
drawCard (player=0, state=0x7fffffff7620) at dominion.c:548
548	    state->discardCount[player] = 0;
551	    count = state->handCount[player];//Get current player's hand count
557	    deckCounter = state->deckCount[player];//Create a holder for the deck count
559	    if (deckCounter == 0)
560	      return -1;
581	}
adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=14, z=46, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
650		  shuffle(currentPlayer, state);
shuffle (player=0, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=7, z=47, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:652
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
533	    for (i = 0; i < state->discardCount[player];i++){
538	    state->deckCount[player] = state->discardCount[player];
539	    state->discardCount[player] = 0;//Reset discard
542	    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
shuffle (player=0, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
drawCard (player=0, state=0x7fffffff7620) at dominion.c:548
548	    state->discardCount[player] = 0;
551	    count = state->handCount[player];//Get current player's hand count
557	    deckCounter = state->deckCount[player];//Create a holder for the deck count
559	    if (deckCounter == 0)
560	      return -1;
581	}
adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=7, z=47, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
655		  drawntreasure++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
650		  shuffle(currentPlayer, state);
shuffle (player=0, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
adventureEffect (drawntreasure=1, currentPlayer=0, cardDrawn=6, z=47, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:652
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
533	    for (i = 0; i < state->discardCount[player];i++){
538	    state->deckCount[player] = state->discardCount[player];
539	    state->discardCount[player] = 0;//Reset discard
542	    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
shuffle (player=0, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
drawCard (player=0, state=0x7fffffff7620) at dominion.c:548
548	    state->discardCount[player] = 0;
551	    count = state->handCount[player];//Get current player's hand count
557	    deckCounter = state->deckCount[player];//Create a holder for the deck count
559	    if (deckCounter == 0)
560	      return -1;
581	}
adventureEffect (drawntreasure=1, currentPlayer=0, cardDrawn=6, z=47, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
655		  drawntreasure++;
648	   while(drawntreasure<2){
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
667	   return 0;
668	}
cardEffect (card=7, choice1=0, choice2=0, choice3=0, state=0x7fffffff7620, handPos=9, bonus=0x7ffffffd6590) at dominion.c:1249
1249	}
main (argc=1, argv=0x7fffffffddd8) at randomtestadventurer.c:137
137	    assertEqualValPair(testG.handCount[currentPlayer], G.handCount[currentPlayer] + draw_total - discarded, hand_count_current, &hand_count_current_errors, dep);
assertEqualValPair (actual=7, expected=11, err_arr=0x7ffffffd6660, counter=0x7ffffffd654c, dep=...) at test_helpers.c:31
31	  if (!(actual == expected)){
32	    err_arr[*counter].actual = actual;
33	    err_arr[*counter].expected = expected;
34	    err_arr[*counter].dep = dep;
35	    (*counter)++;
37	}
main (argc=1, argv=0x7fffffffddd8) at randomtestadventurer.c:138
138	    assertEqualValPair(testG.deckCount[currentPlayer], G.deckCount[currentPlayer] - draw_total, deck_count_current, &deck_count_current_errors, dep);
assertEqualValPair (actual=0, expected=12, err_arr=0x7ffffffd7f60, counter=0x7ffffffd6550, dep=...) at test_helpers.c:31
31	  if (!(actual == expected)){
32	    err_arr[*counter].actual = actual;
33	    err_arr[*counter].expected = expected;
34	    err_arr[*counter].dep = dep;
35	    (*counter)++;
37	}
main (argc=1, argv=0x7fffffffddd8) at randomtestadventurer.c:139
139	    assertEqualValPair(testG.discardCount[currentPlayer], G.discardCount[currentPlayer] + discarded, discard_count_current, &discard_count_current_errors, dep);
assertEqualValPair (actual=47, expected=31, err_arr=0x7ffffffd9860, counter=0x7ffffffd6554, dep=...) at test_helpers.c:31
31	  if (!(actual == expected)){
32	    err_arr[*counter].actual = actual;
33	    err_arr[*counter].expected = expected;
34	    err_arr[*counter].dep = dep;
35	    (*counter)++;
37	}
main (argc=1, argv=0x7fffffffddd8) at randomtestadventurer.c:140
140	    num_treasure_actual = countTreasure(testG.hand[currentPlayer], testG.handCount[currentPlayer]);
countTreasure (cards=0x7fffffff7718, size=7) at test_helpers.c:226
226	    int treasure_count = 0;
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
232	    return treasure_count;
233	}
main (argc=1, argv=0x7fffffffddd8) at randomtestadventurer.c:141
141	    num_treasure_expected = countTreasure(G.hand[currentPlayer], G.handCount[currentPlayer]) + drawnTreasure;
countTreasure (cards=0x7fffffff1058, size=10) at test_helpers.c:226
226	    int treasure_count = 0;
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
229	            treasure_count++;
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
232	    return treasure_count;
233	}
main (argc=1, argv=0x7fffffffddd8) at randomtestadventurer.c:142
142	    assertEqualValPair(num_treasure_actual, num_treasure_expected, treasure_in_hand_current, &treasure_in_hand_current_errors, dep);
assertEqualValPair (actual=0, expected=1, err_arr=0x7ffffffdb160, counter=0x7ffffffd6558, dep=...) at test_helpers.c:31
31	  if (!(actual == expected)){
32	    err_arr[*counter].actual = actual;
33	    err_arr[*counter].expected = expected;
34	    err_arr[*counter].dep = dep;
35	    (*counter)++;
37	}
main (argc=1, argv=0x7fffffffddd8) at randomtestadventurer.c:143
143	    num_treasure_actual = countTreasure(testG.deck[currentPlayer], testG.deckCount[currentPlayer]);
countTreasure (cards=0x7fffffff9668, size=0) at test_helpers.c:226
226	    int treasure_count = 0;
227	    for (int i = 0; i < size; i++){
232	    return treasure_count;
233	}
main (argc=1, argv=0x7fffffffddd8) at randomtestadventurer.c:144
144	    num_treasure_expected = countTreasure(G.deck[currentPlayer], G.deckCount[currentPlayer]) - drawnTreasure;
countTreasure (cards=0x7fffffff2fa8, size=44) at test_helpers.c:226
226	    int treasure_count = 0;
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
229	            treasure_count++;
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
229	            treasure_count++;
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
229	            treasure_count++;
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
229	            treasure_count++;
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
232	    return treasure_count;
233	}
main (argc=1, argv=0x7fffffffddd8) at randomtestadventurer.c:145
145	    assertEqualValPair(num_treasure_actual, num_treasure_expected, treasure_in_deck_current, &treasure_in_deck_current_errors, dep);
assertEqualValPair (actual=0, expected=4, err_arr=0x7ffffffdca60, counter=0x7ffffffd655c, dep=...) at test_helpers.c:31
31	  if (!(actual == expected)){
32	    err_arr[*counter].actual = actual;
33	    err_arr[*counter].expected = expected;
34	    err_arr[*counter].dep = dep;
35	    (*counter)++;
37	}
main (argc=1, argv=0x7fffffffddd8) at randomtestadventurer.c:148
148	    assertEqualValPair(testG.handCount[otherPlayer], G.handCount[otherPlayer], hand_count_other, &hand_count_other_errors, dep);
assertEqualValPair (actual=0, expected=0, err_arr=0x7ffffffde360, counter=0x7ffffffd6560, dep=...) at test_helpers.c:31
31	  if (!(actual == expected)){
37	}
main (argc=1, argv=0x7fffffffddd8) at randomtestadventurer.c:149
149	    assertEqualValPair(testG.deckCount[otherPlayer], G.deckCount[otherPlayer], deck_count_other, &deck_count_other_errors, dep);
assertEqualValPair (actual=10, expected=10, err_arr=0x7ffffffdfc60, counter=0x7ffffffd6564, dep=...) at test_helpers.c:31
31	  if (!(actual == expected)){
37	}
main (argc=1, argv=0x7fffffffddd8) at randomtestadventurer.c:150
150	    assertEqualValPair(testG.discardCount[otherPlayer], G.discardCount[otherPlayer], discard_count_other, &discard_count_other_errors, dep);
assertEqualValPair (actual=0, expected=0, err_arr=0x7ffffffe1560, counter=0x7ffffffd6568, dep=...) at test_helpers.c:31
31	  if (!(actual == expected)){
37	}
main (argc=1, argv=0x7fffffffddd8) at randomtestadventurer.c:151
151	    num_treasure_actual = countTreasure(testG.hand[otherPlayer], testG.handCount[otherPlayer]);
countTreasure (cards=0x7fffffff7ee8, size=0) at test_helpers.c:226
226	    int treasure_count = 0;
227	    for (int i = 0; i < size; i++){
232	    return treasure_count;
233	}
main (argc=1, argv=0x7fffffffddd8) at randomtestadventurer.c:152
152	    num_treasure_expected = countTreasure(G.hand[otherPlayer], G.handCount[otherPlayer]);
countTreasure (cards=0x7fffffff1828, size=0) at test_helpers.c:226
226	    int treasure_count = 0;
227	    for (int i = 0; i < size; i++){
232	    return treasure_count;
233	}
main (argc=1, argv=0x7fffffffddd8) at randomtestadventurer.c:153
153	    assertEqualValPair(num_treasure_actual, num_treasure_expected, treasure_in_hand_other, &treasure_in_hand_other_errors, dep);
assertEqualValPair (actual=0, expected=0, err_arr=0x7ffffffe2e60, counter=0x7ffffffd656c, dep=...) at test_helpers.c:31
31	  if (!(actual == expected)){
37	}
main (argc=1, argv=0x7fffffffddd8) at randomtestadventurer.c:154
154	    num_treasure_actual = countTreasure(testG.deck[otherPlayer], testG.deckCount[otherPlayer]);
countTreasure (cards=0x7fffffff9e38, size=10) at test_helpers.c:226
226	    int treasure_count = 0;
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
229	            treasure_count++;
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
229	            treasure_count++;
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
229	            treasure_count++;
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
229	            treasure_count++;
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
229	            treasure_count++;
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
229	            treasure_count++;
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
229	            treasure_count++;
227	    for (int i = 0; i < size; i++){
232	    return treasure_count;
233	}
main (argc=1, argv=0x7fffffffddd8) at randomtestadventurer.c:155
155	    num_treasure_expected = countTreasure(G.deck[otherPlayer], G.deckCount[otherPlayer]);
countTreasure (cards=0x7fffffff3778, size=10) at test_helpers.c:226
226	    int treasure_count = 0;
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
229	            treasure_count++;
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
229	            treasure_count++;
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
229	            treasure_count++;
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
229	            treasure_count++;
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
229	            treasure_count++;
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
229	            treasure_count++;
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
227	    for (int i = 0; i < size; i++){
228	        if (cards[i] == copper || cards[i] == silver || cards[i] == gold){
229	            treasure_count++;
227	    for (int i = 0; i < size; i++){
232	    return treasure_count;
233	}
main (argc=1, argv=0x7fffffffddd8) at randomtestadventurer.c:156
156	    assertEqualValPair(num_treasure_actual, num_treasure_expected, treasure_in_deck_other, &treasure_in_deck_other_errors, dep);
assertEqualValPair (actual=7, expected=7, err_arr=0x7ffffffe4760, counter=0x7ffffffd6570, dep=...) at test_helpers.c:31
31	  if (!(actual == expected)){
37	}
main (argc=1, argv=0x7fffffffddd8) at randomtestadventurer.c:159
159	    assertEqualValPair(testG.numBuys, G.numBuys + extraBuys, num_buys_diff, &num_buys_diff_errors, dep);
assertEqualValPair (actual=1, expected=1, err_arr=0x7ffffffe6060, counter=0x7ffffffd6574, dep=...) at test_helpers.c:31
31	  if (!(actual == expected)){
37	}
main (argc=1, argv=0x7fffffffddd8) at randomtestadventurer.c:160
160	    bool same_supply = true;
161	    for (int i = 0; i < cards_count; i++){
162	       if (testG.supplyCount[i] != G.supplyCount[i]){
161	    for (int i = 0; i < cards_count; i++){
162	       if (testG.supplyCount[i] != G.supplyCount[i]){
161	    for (int i = 0; i < cards_count; i++){
162	       if (testG.supplyCount[i] != G.supplyCount[i]){
161	    for (int i = 0; i < cards_count; i++){
162	       if (testG.supplyCount[i] != G.supplyCount[i]){
161	    for (int i = 0; i < cards_count; i++){
162	       if (testG.supplyCount[i] != G.supplyCount[i]){
161	    for (int i = 0; i < cards_count; i++){
162	       if (testG.supplyCount[i] != G.supplyCount[i]){
161	    for (int i = 0; i < cards_count; i++){
162	       if (testG.supplyCount[i] != G.supplyCount[i]){
161	    for (int i = 0; i < cards_count; i++){
162	       if (testG.supplyCount[i] != G.supplyCount[i]){
161	    for (int i = 0; i < cards_count; i++){
162	       if (testG.supplyCount[i] != G.supplyCount[i]){
161	    for (int i = 0; i < cards_count; i++){
162	       if (testG.supplyCount[i] != G.supplyCount[i]){
161	    for (int i = 0; i < cards_count; i++){
162	       if (testG.supplyCount[i] != G.supplyCount[i]){
161	    for (int i = 0; i < cards_count; i++){
162	       if (testG.supplyCount[i] != G.supplyCount[i]){
161	    for (int i = 0; i < cards_count; i++){
162	       if (testG.supplyCount[i] != G.supplyCount[i]){
161	    for (int i = 0; i < cards_count; i++){
162	       if (testG.supplyCount[i] != G.supplyCount[i]){
161	    for (int i = 0; i < cards_count; i++){
162	       if (testG.supplyCount[i] != G.supplyCount[i]){
161	    for (int i = 0; i < cards_count; i++){
162	       if (testG.supplyCount[i] != G.supplyCount[i]){
161	    for (int i = 0; i < cards_count; i++){
162	       if (testG.supplyCount[i] != G.supplyCount[i]){
161	    for (int i = 0; i < cards_count; i++){
162	       if (testG.supplyCount[i] != G.supplyCount[i]){
161	    for (int i = 0; i < cards_count; i++){
162	       if (testG.supplyCount[i] != G.supplyCount[i]){
161	    for (int i = 0; i < cards_count; i++){
162	       if (testG.supplyCount[i] != G.supplyCount[i]){
161	    for (int i = 0; i < cards_count; i++){
162	       if (testG.supplyCount[i] != G.supplyCount[i]){
161	    for (int i = 0; i < cards_count; i++){
162	       if (testG.supplyCount[i] != G.supplyCount[i]){
161	    for (int i = 0; i < cards_count; i++){
162	       if (testG.supplyCount[i] != G.supplyCount[i]){
161	    for (int i = 0; i < cards_count; i++){
162	       if (testG.supplyCount[i] != G.supplyCount[i]){
161	    for (int i = 0; i < cards_count; i++){
162	       if (testG.supplyCount[i] != G.supplyCount[i]){
161	    for (int i = 0; i < cards_count; i++){
162	       if (testG.supplyCount[i] != G.supplyCount[i]){
161	    for (int i = 0; i < cards_count; i++){
162	       if (testG.supplyCount[i] != G.supplyCount[i]){
161	    for (int i = 0; i < cards_count; i++){
166	    if (!same_supply){
169	    bool same_tokens = true;
170	    for (int i = 0; i < cards_count; i++){
171	       if (testG.embargoTokens[i] != G.embargoTokens[i]){
170	    for (int i = 0; i < cards_count; i++){
171	       if (testG.embargoTokens[i] != G.embargoTokens[i]){
170	    for (int i = 0; i < cards_count; i++){
171	       if (testG.embargoTokens[i] != G.embargoTokens[i]){
170	    for (int i = 0; i < cards_count; i++){
171	       if (testG.embargoTokens[i] != G.embargoTokens[i]){
170	    for (int i = 0; i < cards_count; i++){
171	       if (testG.embargoTokens[i] != G.embargoTokens[i]){
170	    for (int i = 0; i < cards_count; i++){
171	       if (testG.embargoTokens[i] != G.embargoTokens[i]){
170	    for (int i = 0; i < cards_count; i++){
171	       if (testG.embargoTokens[i] != G.embargoTokens[i]){
170	    for (int i = 0; i < cards_count; i++){
171	       if (testG.embargoTokens[i] != G.embargoTokens[i]){
170	    for (int i = 0; i < cards_count; i++){
171	       if (testG.embargoTokens[i] != G.embargoTokens[i]){
170	    for (int i = 0; i < cards_count; i++){
171	       if (testG.embargoTokens[i] != G.embargoTokens[i]){
170	    for (int i = 0; i < cards_count; i++){
171	       if (testG.embargoTokens[i] != G.embargoTokens[i]){
170	    for (int i = 0; i < cards_count; i++){
171	       if (testG.embargoTokens[i] != G.embargoTokens[i]){
170	    for (int i = 0; i < cards_count; i++){
171	       if (testG.embargoTokens[i] != G.embargoTokens[i]){
170	    for (int i = 0; i < cards_count; i++){
171	       if (testG.embargoTokens[i] != G.embargoTokens[i]){
170	    for (int i = 0; i < cards_count; i++){
171	       if (testG.embargoTokens[i] != G.embargoTokens[i]){
170	    for (int i = 0; i < cards_count; i++){
171	       if (testG.embargoTokens[i] != G.embargoTokens[i]){
170	    for (int i = 0; i < cards_count; i++){
171	       if (testG.embargoTokens[i] != G.embargoTokens[i]){
170	    for (int i = 0; i < cards_count; i++){
171	       if (testG.embargoTokens[i] != G.embargoTokens[i]){
170	    for (int i = 0; i < cards_count; i++){
171	       if (testG.embargoTokens[i] != G.embargoTokens[i]){
170	    for (int i = 0; i < cards_count; i++){
171	       if (testG.embargoTokens[i] != G.embargoTokens[i]){
170	    for (int i = 0; i < cards_count; i++){
171	       if (testG.embargoTokens[i] != G.embargoTokens[i]){
170	    for (int i = 0; i < cards_count; i++){
171	       if (testG.embargoTokens[i] != G.embargoTokens[i]){
170	    for (int i = 0; i < cards_count; i++){
171	       if (testG.embargoTokens[i] != G.embargoTokens[i]){
170	    for (int i = 0; i < cards_count; i++){
171	       if (testG.embargoTokens[i] != G.embargoTokens[i]){
170	    for (int i = 0; i < cards_count; i++){
171	       if (testG.embargoTokens[i] != G.embargoTokens[i]){
170	    for (int i = 0; i < cards_count; i++){
171	       if (testG.embargoTokens[i] != G.embargoTokens[i]){
170	    for (int i = 0; i < cards_count; i++){
171	       if (testG.embargoTokens[i] != G.embargoTokens[i]){
170	    for (int i = 0; i < cards_count; i++){
175	    if (!same_tokens){
178	    assertEqualValPair(testG.outpostPlayed, G.outpostPlayed, outpost_play_diff, &outpost_play_errors, dep);
assertEqualValPair (actual=0, expected=0, err_arr=0x7ffffffe7960, counter=0x7ffffffd6578, dep=...) at test_helpers.c:31
31	  if (!(actual == expected)){
37	}
main (argc=1, argv=0x7fffffffddd8) at randomtestadventurer.c:179
179	    assertEqualValPair(testG.outpostTurn, G.outpostTurn, outpost_turn_diff, &outpost_turn_errors, dep);
assertEqualValPair (actual=0, expected=0, err_arr=0x7ffffffe9260, counter=0x7ffffffd657c, dep=...) at test_helpers.c:31
31	  if (!(actual == expected)){
37	}
main (argc=1, argv=0x7fffffffddd8) at randomtestadventurer.c:180
180	    assertEqualValPair(testG.whoseTurn, G.whoseTurn, whose_turn_diff, &whose_turn_errors, dep);
assertEqualValPair (actual=0, expected=0, err_arr=0x7ffffffeab60, counter=0x7ffffffd6580, dep=...) at test_helpers.c:31
31	  if (!(actual == expected)){
37	}
main (argc=1, argv=0x7fffffffddd8) at randomtestadventurer.c:181
181	    assertEqualValPair(testG.phase, G.phase, phase_diff, &phase_errors, dep);
assertEqualValPair (actual=0, expected=0, err_arr=0x7ffffffec460, counter=0x7ffffffd6584, dep=...) at test_helpers.c:31
31	  if (!(actual == expected)){
37	}
main (argc=1, argv=0x7fffffffddd8) at randomtestadventurer.c:182
182	    assertEqualValPair(testG.numActions, G.numActions + extraActions, num_action_diff, &num_action_errors, dep);
assertEqualValPair (actual=1, expected=1, err_arr=0x7ffffffedd60, counter=0x7ffffffd6588, dep=...) at test_helpers.c:31
31	  if (!(actual == expected)){
37	}
main (argc=1, argv=0x7fffffffddd8) at randomtestadventurer.c:183
183	    assertEqualValPair(testG.playedCardCount, G.playedCardCount + cardsPlayed, played_card_diff, &played_card_errors, dep);
assertEqualValPair (actual=0, expected=1, err_arr=0x7ffffffef660, counter=0x7ffffffd658c, dep=...) at test_helpers.c:31
31	  if (!(actual == expected)){
32	    err_arr[*counter].actual = actual;
33	    err_arr[*counter].expected = expected;
34	    err_arr[*counter].dep = dep;
35	    (*counter)++;
37	}
main (argc=1, argv=0x7fffffffddd8) at randomtestadventurer.c:69
69	  for (int i = 0; i < NUM_TESTS; i++){
75	    int choice1 = 0, choice2 = 0, choice3 = 0, bonus = 0;
76	    int drawnTreasure = 0;
77	    int treasure_needed = 2;  // What adventurer requires of deck
78	    int extraBuys = 0;
79	    int extraActions = 0;
80	    int cardsPlayed = 1;
86	    int discarded = 1;      // At least the 1 Adventurer card will be discarded
92	    initializeGame(numPlayers, k, seed, &G);
initializeGame (numPlayers=2, kingdomCards=0x7ffffffd65f0, randomSeed=1000, state=0x7fffffff0f60) at dominion.c:44
44	  SelectStream(1);
SelectStream (index=1) at rngs.c:147
147	  stream = ((unsigned int) index) % STREAMS;
148	  if ((initialized == 0) && (stream != 0))   /* protect against        */
150	}
initializeGame (numPlayers=2, kingdomCards=0x7ffffffd65f0, randomSeed=1000, state=0x7fffffff0f60) at dominion.c:45
45	  PutSeed((long)randomSeed);
PutSeed (x=1000) at rngs.c:111
111	  char ok = 0;
113	  if (x > 0)
114	    x = x % MODULUS;                       /* correct if x is too large  */
115	  if (x < 0)                                 
117	  if (x == 0)                                
125	  seed[stream] = x;
126	}
initializeGame (numPlayers=2, kingdomCards=0x7ffffffd65f0, randomSeed=1000, state=0x7fffffff0f60) at dominion.c:48
48	  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
54	  state->numPlayers = numPlayers;
57	  for (i = 0; i < 10; i++)
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
57	  for (i = 0; i < 10; i++)
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
57	  for (i = 0; i < 10; i++)
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
57	  for (i = 0; i < 10; i++)
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
57	  for (i = 0; i < 10; i++)
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
57	  for (i = 0; i < 10; i++)
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
57	  for (i = 0; i < 10; i++)
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
57	  for (i = 0; i < 10; i++)
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
57	  for (i = 0; i < 10; i++)
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
57	  for (i = 0; i < 10; i++)
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
61		  if (j != i && kingdomCards[j] == kingdomCards[i])
59	      for (j = 0; j < 10; j++)
57	  for (i = 0; i < 10; i++)
73	  if (numPlayers == 2)
75	      state->supplyCount[curse] = 10;
87	  if (numPlayers == 2)
89	      state->supplyCount[estate] = 8;
90	      state->supplyCount[duchy] = 8;
91	      state->supplyCount[province] = 8;
101	  state->supplyCount[copper] = 60 - (7 * numPlayers);
102	  state->supplyCount[silver] = 40;
103	  state->supplyCount[gold] = 30;
106	  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
108	      for (j = 0; j < 10; j++)           		//loop chosen cards
110		  if (kingdomCards[j] == i)
113		      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
122			  state->supplyCount[i] = 10;
124		      break;
106	  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
108	      for (j = 0; j < 10; j++)           		//loop chosen cards
110		  if (kingdomCards[j] == i)
128		      state->supplyCount[i] = -1;
108	      for (j = 0; j < 10; j++)           		//loop chosen cards
110		  if (kingdomCards[j] == i)
128		      state->supplyCount[i] = -1;
108	      for (j = 0; j < 10; j++)           		//loop chosen cards
110		  if (kingdomCards[j] == i)
128		      state->supplyCount[i] = -1;
108	      for (j = 0; j < 10; j++)           		//loop chosen cards
110		  if (kingdomCards[j] == i)
128		      state->supplyCount[i] = -1;
108	      for (j = 0; j < 10; j++)           		//loop chosen cards
110		  if (kingdomCards[j] == i)
128		      state->supplyCount[i] = -1;
108	      for (j = 0; j < 10; j++)           		//loop chosen cards
110		  if (kingdomCards[j] == i)
128		      state->supplyCount[i] = -1;
108	      for (j = 0; j < 10; j++)           		//loop chosen cards
110		  if (kingdomCards[j] == i)
128		      state->supplyCount[i] = -1;
108	      for (j = 0; j < 10; j++)           		//loop chosen cards
110		  if (kingdomCards[j] == i)
128		      state->supplyCount[i] = -1;
108	      for (j = 0; j < 10; j++)           		//loop chosen cards
110		  if (kingdomCards[j] == i)
128		      state->supplyCount[i] = -1;
108	      for (j = 0; j < 10; j++)           		//loop chosen cards
110		  if (kingdomCards[j] == i)
113		      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
122			  state->supplyCount[i] = 10;
124		      break;
106	  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
108	      for (j = 0; j < 10; j++)           		//loop chosen cards
110		  if (kingdomCards[j] == i)
128		      state->supplyCount[i] = -1;
108	      for (j = 0; j < 10; j++)           		//loop chosen cards
110		  if (kingdomCards[j] == i)
128		      state->supplyCount[i] = -1;
108	      for (j = 0; j < 10; j++)           		//loop chosen cards
110		  if (kingdomCards[j] == i)
128		      state->supplyCount[i] = -1;
108	      for (j = 0; j < 10; j++)           		//loop chosen cards
110		  if (kingdomCards[j] == i)
128		      state->supplyCount[i] = -1;
108	      for (j = 0; j < 10; j++)           		//loop chosen cards
110		  if (kingdomCards[j] == i)
128		      state->supplyCount[i] = -1;
108	      for (j = 0; j < 10; j++)           		//loop chosen cards
110		  if (kingdomCards[j] == i)
128		      state->supplyCount[i] = -1;
108	      for (j = 0; j < 10; j++)           		//loop chosen cards
110		  if (kingdomCards[j] == i)
128		      state->supplyCount[i] = -1;
108	      for (j = 0; j < 10; j++)           		//loop chosen cards
110		  if (kingdomCards[j] == i)
128		      state->supplyCount[i] = -1;
108	      for (j = 0; j < 10; j++)           		//loop chosen cards
110		  if (kingdomCards[j] == i)
128		      state->supplyCount[i] = -1;
108	      for (j = 0; j < 10; j++)           		//loop chosen cards
110		  if (kingdomCards[j] == i)
128		      state->supplyCount[i] = -1;
108	      for (j = 0; j < 10; j++)           		//loop chosen cards
106	  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
108	      for (j = 0; j < 10; j++)           		//loop chosen cards
110		  if (kingdomCards[j] == i)
128		      state->supplyCount[i] = -1;
108	      for (j = 0; j < 10; j++)           		//loop chosen cards
110		  if (kingdomCards[j] == i)
128		      state->supplyCount[i] = -1;
108	      for (j = 0; j < 10; j++)           		//loop chosen cards
110		  if (kingdomCards[j] == i)
128		      state->supplyCount[i] = -1;
108	      for (j = 0; j < 10; j++)           		//loop chosen cards
110		  if (kingdomCards[j] == i)
128		      state->supplyCount[i] = -1;
108	      for (j = 0; j < 10; j++)           		//loop chosen cards
110		  if (kingdomCards[j] == i)
128		      state->supplyCount[i] = -1;
108	      for (j = 0; j < 10; j++)           		//loop chosen cards
110		  if (kingdomCards[j] == i)
128		      state->supplyCount[i] = -1;
108	      for (j = 0; j < 10; j++)           		//loop chosen cards
110		  if (kingdomCards[j] == i)
128		      state->supplyCount[i] = -1;
108	      for (j = 0; j < 10; j++)           		//loop chosen cards
110		  if (kingdomCards[j] == i)
128		      state->supplyCount[i] = -1;
108	      for (j = 0; j < 10; j++)           		//loop chosen cards
110		  if (kingdomCards[j] == i)
128		      state->supplyCount[i] = -1;
108	      for (j = 0; j < 10; j++)           		//loop chosen cards
110		  if (kingdomCards[j] == i)
128		      state->supplyCount[i] = -1;
108	      for (j = 0; j < 10; j++)           		//loop chosen cards
106	  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
108	      for (j = 0; j < 10; j++)           		//loop chosen cards
110		  if (kingdomCards[j] == i)
128		      state->supplyCount[i] = -1;
108	      for (j = 0; j < 10; j++)           		//loop chosen cards
110		  if (kingdomCards[j] == i)
128		      state->supplyCount[i] = -1;
108	      for (j = 0; j < 10; j++)           		//loop chosen cards
110		  if (kingdomCards[j] == i)
128		      state->supplyCount[i] = -1;
108	      for (j = 0; j < 10; j++)           		//loop chosen cards
110		  if (kingdomCards[j] == i)
128		      state->supplyCount[i] = -1;
108	      for (j = 0; j < 10; j++)           		//loop chosen cards
110		  if (kingdomCards[j] == i)
113		      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
122			  state->supplyCount[i] = 10;
124		      break;
Program not restarted.
Continuing.

Breakpoint 1, adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=0, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:648
648	   while(drawntreasure<2){
Continuing.

Program received signal SIGABRT, Aborted.
__GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50
50	../sysdeps/unix/sysv/linux/raise.c: No such file or directory.
Continuing.

Program terminated with signal SIGABRT, Aborted.
The program no longer exists.
The program is not being run.
The program is not being run.
The program is not being run.
The program is not being run.
The program is not being run.
The program is not being run.
The program is not being run.
The program is not being run.
The program is not being run.
The program is not being run.
The program is not being run.
The program is not being run.
The program is not being run.
The program is not being run.
The program is not being run.
The program is not being run.
No symbol "satte" in current context.
Value can't be converted to integer.
Value can't be converted to integer.
Undefined command: "quity".  Try "help".
Starting program: /home/dlamartina/School/CS362/CS362-W2019/projects/lamartid/nelsoryaDominion/randomtestadventurer 

Program received signal SIGABRT, Aborted.
__GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50
50	../sysdeps/unix/sysv/linux/raise.c: No such file or directory.
Function "dominion.c::adventureEffect" not defined.
Breakpoint 1 at 0x55555555c1c7: file dominion.c, line 653.
Starting program: /home/dlamartina/School/CS362/CS362-W2019/projects/lamartid/nelsoryaDominion/randomtestadventurer 

Breakpoint 1, adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=0, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
Continuing.

Breakpoint 1, adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=1, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
Continuing.

Breakpoint 1, adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=2, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
$1 = 3
$2 = {{22, 4, 5, 7, 5, 12, 24, 7, 19, 22, 4, 0 <repeats 489 times>}, {0 <repeats 500 times>}, {0 <repeats 500 times>}, {0 <repeats 500 times>}}
$3 = 10
Continuing.

Breakpoint 1, adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=3, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
Continuing.

Breakpoint 1, adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=4, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
Continuing.

Breakpoint 1, adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=5, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
Continuing.

Breakpoint 1, adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=6, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}
Continuing.

Breakpoint 1, adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=7, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}

Breakpoint 1, adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=8, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}

Breakpoint 1, adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=9, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}

Breakpoint 1, adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=10, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}

Breakpoint 1, adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=11, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}

Breakpoint 1, adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=12, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}

Breakpoint 1, adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=13, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}

Breakpoint 1, adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=14, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}

Breakpoint 1, adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=15, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}

Breakpoint 1, adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=16, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
$4 = 16
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
652		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
568	    int count = state->handCount[player];//Get current hand count for player
574	    deckCounter = state->deckCount[player];//Create holder for the deck count
575	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
576	    state->deckCount[player]--;
577	    state->handCount[player]++;//Increment hand count
580	  return 0;
581	}

Breakpoint 1, adventureEffect (drawntreasure=0, currentPlayer=0, cardDrawn=0, z=17, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
Continuing.

Breakpoint 1, adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=500, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
650		  shuffle(currentPlayer, state);
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=501, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:652
652		drawCard(currentPlayer, state);
drawCard (player=1, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
533	    for (i = 0; i < state->discardCount[player];i++){
538	    state->deckCount[player] = state->discardCount[player];
539	    state->discardCount[player] = 0;//Reset discard
542	    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
drawCard (player=1, state=0x7fffffff7620) at dominion.c:548
548	    state->discardCount[player] = 0;
551	    count = state->handCount[player];//Get current player's hand count
557	    deckCounter = state->deckCount[player];//Create a holder for the deck count
559	    if (deckCounter == 0)
560	      return -1;
581	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=501, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
650		  shuffle(currentPlayer, state);
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=502, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:652
652		drawCard(currentPlayer, state);
drawCard (player=1, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
533	    for (i = 0; i < state->discardCount[player];i++){
538	    state->deckCount[player] = state->discardCount[player];
539	    state->discardCount[player] = 0;//Reset discard
542	    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
No symbol "z" in current context.
210	    return -1;
229	}
drawCard (player=1, state=0x7fffffff7620) at dominion.c:548
548	    state->discardCount[player] = 0;
551	    count = state->handCount[player];//Get current player's hand count
557	    deckCounter = state->deckCount[player];//Create a holder for the deck count
559	    if (deckCounter == 0)
560	      return -1;
581	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=502, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
$5 = 502
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
650		  shuffle(currentPlayer, state);
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=503, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:652
652		drawCard(currentPlayer, state);
drawCard (player=1, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
533	    for (i = 0; i < state->discardCount[player];i++){
538	    state->deckCount[player] = state->discardCount[player];
539	    state->discardCount[player] = 0;//Reset discard
542	    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
drawCard (player=1, state=0x7fffffff7620) at dominion.c:548
548	    state->discardCount[player] = 0;
551	    count = state->handCount[player];//Get current player's hand count
557	    deckCounter = state->deckCount[player];//Create a holder for the deck count
559	    if (deckCounter == 0)
560	      return -1;
581	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=503, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
$6 = 503
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
650		  shuffle(currentPlayer, state);
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=504, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:652
652		drawCard(currentPlayer, state);
drawCard (player=1, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
533	    for (i = 0; i < state->discardCount[player];i++){
538	    state->deckCount[player] = state->discardCount[player];
539	    state->discardCount[player] = 0;//Reset discard
542	    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
drawCard (player=1, state=0x7fffffff7620) at dominion.c:548
548	    state->discardCount[player] = 0;
551	    count = state->handCount[player];//Get current player's hand count
557	    deckCounter = state->deckCount[player];//Create a holder for the deck count
559	    if (deckCounter == 0)
560	      return -1;
581	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=504, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
$7 = 504
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
650		  shuffle(currentPlayer, state);
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=505, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:652
652		drawCard(currentPlayer, state);
drawCard (player=1, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
533	    for (i = 0; i < state->discardCount[player];i++){
538	    state->deckCount[player] = state->discardCount[player];
No symbol "z" in current context.
539	    state->discardCount[player] = 0;//Reset discard
542	    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
drawCard (player=1, state=0x7fffffff7620) at dominion.c:548
548	    state->discardCount[player] = 0;
551	    count = state->handCount[player];//Get current player's hand count
557	    deckCounter = state->deckCount[player];//Create a holder for the deck count
559	    if (deckCounter == 0)
560	      return -1;
581	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=505, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
$8 = 505
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
650		  shuffle(currentPlayer, state);
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=506, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:652
652		drawCard(currentPlayer, state);
drawCard (player=1, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
533	    for (i = 0; i < state->discardCount[player];i++){
538	    state->deckCount[player] = state->discardCount[player];
539	    state->discardCount[player] = 0;//Reset discard
542	    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
drawCard (player=1, state=0x7fffffff7620) at dominion.c:548
548	    state->discardCount[player] = 0;
551	    count = state->handCount[player];//Get current player's hand count
557	    deckCounter = state->deckCount[player];//Create a holder for the deck count
559	    if (deckCounter == 0)
560	      return -1;
581	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=506, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
$9 = 506
$10 = -452
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
Continuing.

Program received signal SIGABRT, Aborted.
__GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50
50	../sysdeps/unix/sysv/linux/raise.c: No such file or directory.
#0  __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50
#1  0x00007ffff7c61535 in __GI_abort () at abort.c:79
#2  0x00007ffff7cc8516 in __libc_message (action=action@entry=do_abort, fmt=fmt@entry=0x7ffff7dec9ee "*** %s ***: %s terminated\n") at ../sysdeps/posix/libc_fatal.c:181
#3  0x00007ffff7d6c431 in __GI___fortify_fail_abort (need_backtrace=need_backtrace@entry=false, msg=msg@entry=0x7ffff7dec9cc "stack smashing detected") at fortify_fail.c:33
#4  0x00007ffff7d6c3f2 in __stack_chk_fail () at stack_chk_fail.c:29
#5  0x000055555555edda in cardEffect (card=7, choice1=0, choice2=0, choice3=0, state=0x7fffffff7620, handPos=1, bonus=0x7ffffffd6590) at dominion.c:1249
#6  0x0000000000000000 in ?? ()
Starting program: /home/dlamartina/School/CS362/CS362-W2019/projects/lamartid/nelsoryaDominion/randomtestadventurer 

Breakpoint 1, adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=506, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
$11 = 506
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
$12 = 506
648	   while(drawntreasure<2){
$13 = 507
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
650		  shuffle(currentPlayer, state);
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=507, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:652
652		drawCard(currentPlayer, state);
$14 = 507
drawCard (player=1, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
533	    for (i = 0; i < state->discardCount[player];i++){
538	    state->deckCount[player] = state->discardCount[player];
539	    state->discardCount[player] = 0;//Reset discard
542	    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
No symbol "z" in current context.
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
drawCard (player=1, state=0x7fffffff7620) at dominion.c:548
548	    state->discardCount[player] = 0;
551	    count = state->handCount[player];//Get current player's hand count
557	    deckCounter = state->deckCount[player];//Create a holder for the deck count
559	    if (deckCounter == 0)
560	      return -1;
581	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=507, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
$15 = 507
$16 = -465
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
$17 = 507
659		  z++;
648	   while(drawntreasure<2){
$18 = 508
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
650		  shuffle(currentPlayer, state);
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=508, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:652
652		drawCard(currentPlayer, state);
drawCard (player=1, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
533	    for (i = 0; i < state->discardCount[player];i++){
No symbol "z" in current context.
538	    state->deckCount[player] = state->discardCount[player];
539	    state->discardCount[player] = 0;//Reset discard
542	    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
drawCard (player=1, state=0x7fffffff7620) at dominion.c:548
548	    state->discardCount[player] = 0;
551	    count = state->handCount[player];//Get current player's hand count
557	    deckCounter = state->deckCount[player];//Create a holder for the deck count
559	    if (deckCounter == 0)
560	      return -1;
581	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=508, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
$19 = 508
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
$20 = 508
$21 = -466
659		  z++;
648	   while(drawntreasure<2){
$22 = 509
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
650		  shuffle(currentPlayer, state);
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=509, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:652
652		drawCard(currentPlayer, state);
drawCard (player=1, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
533	    for (i = 0; i < state->discardCount[player];i++){
538	    state->deckCount[player] = state->discardCount[player];
539	    state->discardCount[player] = 0;//Reset discard
542	    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
drawCard (player=1, state=0x7fffffff7620) at dominion.c:548
548	    state->discardCount[player] = 0;
551	    count = state->handCount[player];//Get current player's hand count
557	    deckCounter = state->deckCount[player];//Create a holder for the deck count
559	    if (deckCounter == 0)
560	      return -1;
581	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=509, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
$23 = 509
$24 = -467
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
650		  shuffle(currentPlayer, state);
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=510, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:652
652		drawCard(currentPlayer, state);
drawCard (player=1, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
533	    for (i = 0; i < state->discardCount[player];i++){
538	    state->deckCount[player] = state->discardCount[player];
539	    state->discardCount[player] = 0;//Reset discard
542	    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
drawCard (player=1, state=0x7fffffff7620) at dominion.c:548
548	    state->discardCount[player] = 0;
551	    count = state->handCount[player];//Get current player's hand count
557	    deckCounter = state->deckCount[player];//Create a holder for the deck count
559	    if (deckCounter == 0)
560	      return -1;
581	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=510, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
$25 = 510
$26 = -468
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
650		  shuffle(currentPlayer, state);
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=511, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:652
652		drawCard(currentPlayer, state);
drawCard (player=1, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
533	    for (i = 0; i < state->discardCount[player];i++){
538	    state->deckCount[player] = state->discardCount[player];
539	    state->discardCount[player] = 0;//Reset discard
542	    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
drawCard (player=1, state=0x7fffffff7620) at dominion.c:548
548	    state->discardCount[player] = 0;
551	    count = state->handCount[player];//Get current player's hand count
557	    deckCounter = state->deckCount[player];//Create a holder for the deck count
559	    if (deckCounter == 0)
560	      return -1;
581	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=511, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
$27 = 511
$28 = -469
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
650		  shuffle(currentPlayer, state);
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=512, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:652
652		drawCard(currentPlayer, state);
drawCard (player=1, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
533	    for (i = 0; i < state->discardCount[player];i++){
538	    state->deckCount[player] = state->discardCount[player];
539	    state->discardCount[player] = 0;//Reset discard
542	    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
Continuing.

Program received signal SIGABRT, Aborted.
__GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50
50	../sysdeps/unix/sysv/linux/raise.c: No such file or directory.
#0  __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50
#1  0x00007ffff7c61535 in __GI_abort () at abort.c:79
#2  0x00007ffff7cc8516 in __libc_message (action=action@entry=do_abort, fmt=fmt@entry=0x7ffff7dec9ee "*** %s ***: %s terminated\n") at ../sysdeps/posix/libc_fatal.c:181
#3  0x00007ffff7d6c431 in __GI___fortify_fail_abort (need_backtrace=need_backtrace@entry=false, msg=msg@entry=0x7ffff7dec9cc "stack smashing detected") at fortify_fail.c:33
#4  0x00007ffff7d6c3f2 in __stack_chk_fail () at stack_chk_fail.c:29
#5  0x000055555555edda in cardEffect (card=7, choice1=0, choice2=0, choice3=0, state=0x7fffffff7620, handPos=6, bonus=0x7ffffffd6590) at dominion.c:1249
#6  0x0000000000000000 in ?? ()
#5  0x000055555555edda in cardEffect (card=7, choice1=0, choice2=0, choice3=0, state=0x7fffffff7620, handPos=6, bonus=0x7ffffffd6590) at dominion.c:1249
1249	}
i = 0
j = 1
k = 0
x = 10
index = 10
currentPlayer = 1
nextPlayer = 0
tributeRevealedCards = {-1, -1}
temphand = {0 <repeats 35 times>, 20, 13, 7, 27, 7, 21, 19, 26, 7, 0 <repeats 456 times>}
drawntreasure = 0
cardDrawn = 0
z = 0
Starting program: /home/dlamartina/School/CS362/CS362-W2019/projects/lamartid/nelsoryaDominion/randomtestadventurer 

Program received signal SIGABRT, Aborted.
__GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50
50	../sysdeps/unix/sysv/linux/raise.c: No such file or directory.
Starting program: /home/dlamartina/School/CS362/CS362-W2019/projects/lamartid/nelsoryaDominion/randomtestadventurer 

Program received signal SIGABRT, Aborted.
__GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50
50	../sysdeps/unix/sysv/linux/raise.c: No such file or directory.
Bad breakpoint argument: '1==525'
Starting program: /home/dlamartina/School/CS362/CS362-W2019/projects/lamartid/nelsoryaDominion/randomtestadventurer 

Breakpoint 1, adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=525, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
650		  shuffle(currentPlayer, state);
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=526, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:652
652		drawCard(currentPlayer, state);
drawCard (player=1, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
533	    for (i = 0; i < state->discardCount[player];i++){
538	    state->deckCount[player] = state->discardCount[player];
539	    state->discardCount[player] = 0;//Reset discard
542	    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
drawCard (player=1, state=0x7fffffff7620) at dominion.c:548
548	    state->discardCount[player] = 0;
551	    count = state->handCount[player];//Get current player's hand count
557	    deckCounter = state->deckCount[player];//Create a holder for the deck count
559	    if (deckCounter == 0)
560	      return -1;
581	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=526, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
650		  shuffle(currentPlayer, state);
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=527, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:652
652		drawCard(currentPlayer, state);
$29 = 527
$30 = 527
drawCard (player=1, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
533	    for (i = 0; i < state->discardCount[player];i++){
538	    state->deckCount[player] = state->discardCount[player];
539	    state->discardCount[player] = 0;//Reset discard
542	    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
drawCard (player=1, state=0x7fffffff7620) at dominion.c:548
548	    state->discardCount[player] = 0;
551	    count = state->handCount[player];//Get current player's hand count
557	    deckCounter = state->deckCount[player];//Create a holder for the deck count
559	    if (deckCounter == 0)
560	      return -1;
581	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=527, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
650		  shuffle(currentPlayer, state);
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=528, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:652
652		drawCard(currentPlayer, state);
drawCard (player=1, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
533	    for (i = 0; i < state->discardCount[player];i++){
538	    state->deckCount[player] = state->discardCount[player];
539	    state->discardCount[player] = 0;//Reset discard
542	    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
drawCard (player=1, state=0x7fffffff7620) at dominion.c:548
548	    state->discardCount[player] = 0;
551	    count = state->handCount[player];//Get current player's hand count
557	    deckCounter = state->deckCount[player];//Create a holder for the deck count
559	    if (deckCounter == 0)
560	      return -1;
581	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=528, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
650		  shuffle(currentPlayer, state);
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=529, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:652
652		drawCard(currentPlayer, state);
drawCard (player=1, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
533	    for (i = 0; i < state->discardCount[player];i++){
538	    state->deckCount[player] = state->discardCount[player];
539	    state->discardCount[player] = 0;//Reset discard
542	    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
drawCard (player=1, state=0x7fffffff7620) at dominion.c:548
548	    state->discardCount[player] = 0;
551	    count = state->handCount[player];//Get current player's hand count
557	    deckCounter = state->deckCount[player];//Create a holder for the deck count
559	    if (deckCounter == 0)
560	      return -1;
581	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=529, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
650		  shuffle(currentPlayer, state);
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=530, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:652
652		drawCard(currentPlayer, state);
drawCard (player=1, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
533	    for (i = 0; i < state->discardCount[player];i++){
538	    state->deckCount[player] = state->discardCount[player];
539	    state->discardCount[player] = 0;//Reset discard
542	    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
drawCard (player=1, state=0x7fffffff7620) at dominion.c:548
548	    state->discardCount[player] = 0;
551	    count = state->handCount[player];//Get current player's hand count
557	    deckCounter = state->deckCount[player];//Create a holder for the deck count
559	    if (deckCounter == 0)
560	      return -1;
581	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=530, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
650		  shuffle(currentPlayer, state);
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=531, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:652
652		drawCard(currentPlayer, state);
drawCard (player=1, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
533	    for (i = 0; i < state->discardCount[player];i++){
538	    state->deckCount[player] = state->discardCount[player];
539	    state->discardCount[player] = 0;//Reset discard
542	    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
drawCard (player=1, state=0x7fffffff7620) at dominion.c:548
548	    state->discardCount[player] = 0;
551	    count = state->handCount[player];//Get current player's hand count
557	    deckCounter = state->deckCount[player];//Create a holder for the deck count
559	    if (deckCounter == 0)
560	      return -1;
581	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=531, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
$31 = 531
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
650		  shuffle(currentPlayer, state);
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=532, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:652
652		drawCard(currentPlayer, state);
drawCard (player=1, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
533	    for (i = 0; i < state->discardCount[player];i++){
538	    state->deckCount[player] = state->discardCount[player];
539	    state->discardCount[player] = 0;//Reset discard
542	    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
drawCard (player=1, state=0x7fffffff7620) at dominion.c:548
548	    state->discardCount[player] = 0;
551	    count = state->handCount[player];//Get current player's hand count
557	    deckCounter = state->deckCount[player];//Create a holder for the deck count
559	    if (deckCounter == 0)
560	      return -1;
581	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=532, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
650		  shuffle(currentPlayer, state);
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=533, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:652
652		drawCard(currentPlayer, state);
drawCard (player=1, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
533	    for (i = 0; i < state->discardCount[player];i++){
538	    state->deckCount[player] = state->discardCount[player];
539	    state->discardCount[player] = 0;//Reset discard
542	    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
drawCard (player=1, state=0x7fffffff7620) at dominion.c:548
548	    state->discardCount[player] = 0;
551	    count = state->handCount[player];//Get current player's hand count
557	    deckCounter = state->deckCount[player];//Create a holder for the deck count
559	    if (deckCounter == 0)
560	      return -1;
581	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=533, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
650		  shuffle(currentPlayer, state);
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=534, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:652
652		drawCard(currentPlayer, state);
drawCard (player=1, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
533	    for (i = 0; i < state->discardCount[player];i++){
538	    state->deckCount[player] = state->discardCount[player];
539	    state->discardCount[player] = 0;//Reset discard
542	    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
drawCard (player=1, state=0x7fffffff7620) at dominion.c:548
548	    state->discardCount[player] = 0;
551	    count = state->handCount[player];//Get current player's hand count
557	    deckCounter = state->deckCount[player];//Create a holder for the deck count
559	    if (deckCounter == 0)
560	      return -1;
581	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=534, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
$32 = 535
650		  shuffle(currentPlayer, state);
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=535, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:652
652		drawCard(currentPlayer, state);
drawCard (player=1, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
533	    for (i = 0; i < state->discardCount[player];i++){
538	    state->deckCount[player] = state->discardCount[player];
539	    state->discardCount[player] = 0;//Reset discard
542	    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
drawCard (player=1, state=0x7fffffff7620) at dominion.c:548
548	    state->discardCount[player] = 0;
551	    count = state->handCount[player];//Get current player's hand count
557	    deckCounter = state->deckCount[player];//Create a holder for the deck count
559	    if (deckCounter == 0)
560	      return -1;
581	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=535, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
650		  shuffle(currentPlayer, state);
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=536, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:652
652		drawCard(currentPlayer, state);
drawCard (player=1, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
533	    for (i = 0; i < state->discardCount[player];i++){
538	    state->deckCount[player] = state->discardCount[player];
539	    state->discardCount[player] = 0;//Reset discard
542	    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
drawCard (player=1, state=0x7fffffff7620) at dominion.c:548
548	    state->discardCount[player] = 0;
551	    count = state->handCount[player];//Get current player's hand count
557	    deckCounter = state->deckCount[player];//Create a holder for the deck count
559	    if (deckCounter == 0)
560	      return -1;
581	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=536, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
650		  shuffle(currentPlayer, state);
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=537, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:652
652		drawCard(currentPlayer, state);
drawCard (player=1, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
533	    for (i = 0; i < state->discardCount[player];i++){
538	    state->deckCount[player] = state->discardCount[player];
539	    state->discardCount[player] = 0;//Reset discard
542	    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
drawCard (player=1, state=0x7fffffff7620) at dominion.c:548
548	    state->discardCount[player] = 0;
551	    count = state->handCount[player];//Get current player's hand count
557	    deckCounter = state->deckCount[player];//Create a holder for the deck count
559	    if (deckCounter == 0)
560	      return -1;
581	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=537, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
650		  shuffle(currentPlayer, state);
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
No symbol "z" in current context.
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=538, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:652
652		drawCard(currentPlayer, state);
drawCard (player=1, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
533	    for (i = 0; i < state->discardCount[player];i++){
538	    state->deckCount[player] = state->discardCount[player];
539	    state->discardCount[player] = 0;//Reset discard
542	    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
drawCard (player=1, state=0x7fffffff7620) at dominion.c:548
548	    state->discardCount[player] = 0;
551	    count = state->handCount[player];//Get current player's hand count
557	    deckCounter = state->deckCount[player];//Create a holder for the deck count
559	    if (deckCounter == 0)
560	      return -1;
581	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=538, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
$33 = 538
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
650		  shuffle(currentPlayer, state);
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=539, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:652
652		drawCard(currentPlayer, state);
drawCard (player=1, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
533	    for (i = 0; i < state->discardCount[player];i++){
538	    state->deckCount[player] = state->discardCount[player];
539	    state->discardCount[player] = 0;//Reset discard
542	    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
drawCard (player=1, state=0x7fffffff7620) at dominion.c:548
548	    state->discardCount[player] = 0;
551	    count = state->handCount[player];//Get current player's hand count
557	    deckCounter = state->deckCount[player];//Create a holder for the deck count
559	    if (deckCounter == 0)
560	      return -1;
581	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=539, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
650		  shuffle(currentPlayer, state);
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=540, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:652
652		drawCard(currentPlayer, state);
drawCard (player=1, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
533	    for (i = 0; i < state->discardCount[player];i++){
538	    state->deckCount[player] = state->discardCount[player];
539	    state->discardCount[player] = 0;//Reset discard
542	    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
drawCard (player=1, state=0x7fffffff7620) at dominion.c:548
548	    state->discardCount[player] = 0;
551	    count = state->handCount[player];//Get current player's hand count
557	    deckCounter = state->deckCount[player];//Create a holder for the deck count
559	    if (deckCounter == 0)
560	      return -1;
581	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=540, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
$34 = 540
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
650		  shuffle(currentPlayer, state);
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=541, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:652
652		drawCard(currentPlayer, state);
drawCard (player=1, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
533	    for (i = 0; i < state->discardCount[player];i++){
538	    state->deckCount[player] = state->discardCount[player];
539	    state->discardCount[player] = 0;//Reset discard
542	    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
drawCard (player=1, state=0x7fffffff7620) at dominion.c:548
548	    state->discardCount[player] = 0;
551	    count = state->handCount[player];//Get current player's hand count
557	    deckCounter = state->deckCount[player];//Create a holder for the deck count
559	    if (deckCounter == 0)
560	      return -1;
581	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=541, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
650		  shuffle(currentPlayer, state);
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=542, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:652
652		drawCard(currentPlayer, state);
drawCard (player=1, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
533	    for (i = 0; i < state->discardCount[player];i++){
538	    state->deckCount[player] = state->discardCount[player];
539	    state->discardCount[player] = 0;//Reset discard
542	    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
drawCard (player=1, state=0x7fffffff7620) at dominion.c:548
548	    state->discardCount[player] = 0;
551	    count = state->handCount[player];//Get current player's hand count
557	    deckCounter = state->deckCount[player];//Create a holder for the deck count
559	    if (deckCounter == 0)
560	      return -1;
581	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=542, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
$35 = 542
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
650		  shuffle(currentPlayer, state);
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=543, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:652
652		drawCard(currentPlayer, state);
drawCard (player=1, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
533	    for (i = 0; i < state->discardCount[player];i++){
538	    state->deckCount[player] = state->discardCount[player];
539	    state->discardCount[player] = 0;//Reset discard
542	    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
drawCard (player=1, state=0x7fffffff7620) at dominion.c:548
548	    state->discardCount[player] = 0;
551	    count = state->handCount[player];//Get current player's hand count
557	    deckCounter = state->deckCount[player];//Create a holder for the deck count
559	    if (deckCounter == 0)
560	      return -1;
581	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=543, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
650		  shuffle(currentPlayer, state);
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=544, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:652
652		drawCard(currentPlayer, state);
drawCard (player=1, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
533	    for (i = 0; i < state->discardCount[player];i++){
538	    state->deckCount[player] = state->discardCount[player];
539	    state->discardCount[player] = 0;//Reset discard
542	    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
drawCard (player=1, state=0x7fffffff7620) at dominion.c:548
548	    state->discardCount[player] = 0;
551	    count = state->handCount[player];//Get current player's hand count
557	    deckCounter = state->deckCount[player];//Create a holder for the deck count
559	    if (deckCounter == 0)
560	      return -1;
581	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=544, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
650		  shuffle(currentPlayer, state);
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=545, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:652
652		drawCard(currentPlayer, state);
drawCard (player=1, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
533	    for (i = 0; i < state->discardCount[player];i++){
538	    state->deckCount[player] = state->discardCount[player];
539	    state->discardCount[player] = 0;//Reset discard
542	    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
drawCard (player=1, state=0x7fffffff7620) at dominion.c:548
548	    state->discardCount[player] = 0;
551	    count = state->handCount[player];//Get current player's hand count
557	    deckCounter = state->deckCount[player];//Create a holder for the deck count
559	    if (deckCounter == 0)
560	      return -1;
581	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=545, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
657		  temphand[z]=cardDrawn;
658		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
659		  z++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
650		  shuffle(currentPlayer, state);
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=546, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:652
652		drawCard(currentPlayer, state);
drawCard (player=1, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
533	    for (i = 0; i < state->discardCount[player];i++){
538	    state->deckCount[player] = state->discardCount[player];
539	    state->discardCount[player] = 0;//Reset discard
542	    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
drawCard (player=1, state=0x7fffffff7620) at dominion.c:548
548	    state->discardCount[player] = 0;
551	    count = state->handCount[player];//Get current player's hand count
557	    deckCounter = state->deckCount[player];//Create a holder for the deck count
559	    if (deckCounter == 0)
560	      return -1;
581	}
adventureEffect (drawntreasure=0, currentPlayer=1, cardDrawn=0, z=546, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
655		  drawntreasure++;
648	   while(drawntreasure<2){
649		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
650		  shuffle(currentPlayer, state);
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
adventureEffect (drawntreasure=1, currentPlayer=1, cardDrawn=4, z=546, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:652
652		drawCard(currentPlayer, state);
drawCard (player=1, state=0x7fffffff7620) at dominion.c:528
528	  if (state->deckCount[player] <= 0){//Deck is empty
533	    for (i = 0; i < state->discardCount[player];i++){
538	    state->deckCount[player] = state->discardCount[player];
539	    state->discardCount[player] = 0;//Reset discard
542	    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
shuffle (player=1, state=0x7fffffff7620) at dominion.c:201
201	int shuffle(int player, struct gameState *state) {
205	  int newDeckPos = 0;
209	  if (state->deckCount[player] < 1)
210	    return -1;
229	}
drawCard (player=1, state=0x7fffffff7620) at dominion.c:548
548	    state->discardCount[player] = 0;
551	    count = state->handCount[player];//Get current player's hand count
557	    deckCounter = state->deckCount[player];//Create a holder for the deck count
559	    if (deckCounter == 0)
560	      return -1;
581	}
adventureEffect (drawntreasure=1, currentPlayer=1, cardDrawn=4, z=546, temphand=0x7ffffffd5d20, state=0x7fffffff7620) at dominion.c:653
653		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card. // I changed -1 to +1
654		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
655		  drawntreasure++;
$36 = 546
648	   while(drawntreasure<2){
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
$37 = 519
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
$38 = 499
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
$39 = 484
No symbol "discard" in current context.
$40 = 484
$41 = {0 <repeats 500 times>}
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
$42 = 444
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
$43 = 357
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
$44 = 308
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
$45 = 240
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
$46 = 154
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
$47 = 64
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
$48 = 32
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
$49 = 8
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
$50 = 5
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
663		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
664		z=z-1;
662	   while(z-1>=0){
667	   return 0;
668	}
cardEffect (card=7, choice1=0, choice2=0, choice3=0, state=0x7fffffff7620, handPos=2, bonus=0x7ffffffd6590) at dominion.c:1249
1249	}
$51 = 0
__stack_chk_fail () at stack_chk_fail.c:29
29	stack_chk_fail.c: No such file or directory.
__GI___fortify_fail_abort (need_backtrace=need_backtrace@entry=false, msg=msg@entry=0x7ffff7dec9cc "stack smashing detected") at fortify_fail.c:28
28	fortify_fail.c: No such file or directory.
33	in fortify_fail.c
